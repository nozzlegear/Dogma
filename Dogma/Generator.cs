using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Dogma.Attributes;
using Dogma.Entities;

namespace Dogma
{
    public class Generator
    {
        public async Task<IEnumerable<GeneratedFile>> GenerateFiles(Assembly assembly)
        {
            // Keep references to all classes that we create. We'll prune duplicates after
            // all classes have been generated and then combine them into single modules.
            List<GeneratedInterface> classes = new List<GeneratedInterface>();
            string nl = Environment.NewLine;
            string tab = "\t";

            foreach (var data in GetTypesWithAttribute(assembly))
            {   
                StringBuilder sb = new StringBuilder();
                
                sb.AppendLine(tab + $"export interface {data.TypeInfo.Name} {{");

                foreach (var prop in data.TypeInfo.DeclaredProperties)
                {
                    sb.AppendLine(tab + tab + $"{prop.Name}?: {GetTSType(prop.PropertyType)};");
                }
                
                sb.AppendLine(tab + "}");

                string code = sb.ToString();
                classes.Add(new GeneratedInterface(data.Attribute.ModuleName, code));
            }

            return classes.GroupBy(c => c.ModuleName)
                .Select(module => 
                {
                    string moduleName = module.First().ModuleName;
                    string code = string.Join("", module.Select(m => m.Code));
                    StringBuilder sb = new StringBuilder();

                    sb.AppendLine("/// <auto-generated>");
                    sb.AppendLine($"/// This code was auto-generated by Dogma for .NET Core on {DateTime.UtcNow} UTC. Do not manually edit this file.");
                    sb.AppendLine("/// </auto-generated>");
                    sb.AppendLine($"declare module \"{moduleName}\" {{");
                    sb.Append(code);
                    sb.Append("}");

                    return new GeneratedFile(moduleName, sb.ToString());
                });
        }

        private IEnumerable<TypeData> GetTypesWithAttribute(Assembly assembly)
        {
            foreach (TypeInfo info in assembly.DefinedTypes)
            {
                var attribute = info.GetCustomAttribute(typeof(ToTypeScriptAttribute), true) as ToTypeScriptAttribute;

                if (attribute != null)
                {
                    var data = new TypeData()
                    {
                        TypeInfo = info,
                        Attribute = attribute
                    };

                    yield return data;
                }
            }
        }

        private string GetTSType(Type type)
        {
            if (type.IsConstructedGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
            {
                return "string[]";
            } 

            if (type == typeof(String))
            {
                return "string";
            }

            if (type == typeof(Boolean))
            {
                return "boolean";
            }

            if (type == typeof(int) || type == typeof(decimal) || type == typeof(double) || type == typeof(float))
            {
                return "number";
            }

            return type.Name;
        }
    }
}