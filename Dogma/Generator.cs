using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Dogma.Attributes;
using Dogma.Entities;

namespace Dogma
{
    public class Generator
    {
        public async Task<IEnumerable<GeneratedFile>> GenerateFiles(Assembly assembly)
        {
            // Keep references to all classes that we create. We'll prune duplicates after
            // all classes have been generated and then combine them into single modules.
            List<GeneratedInterface> classes = new List<GeneratedInterface>();
            string nl = Environment.NewLine;
            string tab = "\t";
            var assemblyTypes = GetTypesWithAttribute(assembly);
            var discoveredClasses = assemblyTypes.Select(a => DiscoverClassesFromProps(a.TypeInfo));
            
            // TODO: Use recursion to iterate over all discovered classes, checking the property
            // types for other classes to add to the discovered list.

            foreach (var data in GetTypesWithAttribute(assembly))
            {   
                StringBuilder sb = new StringBuilder();
                
                sb.AppendLine(tab + $"export interface {data.TypeInfo.Name} {{");

                foreach (var prop in data.TypeInfo.DeclaredProperties)
                {
                    sb.AppendLine(tab + tab + $"{prop.Name}?: {GetTSType(prop.PropertyType)};");
                }
                
                sb.AppendLine(tab + "}");

                string code = sb.ToString();
                classes.Add(new GeneratedInterface(data.Attribute.ModuleName, code));
            }

            return classes.GroupBy(c => c.ModuleName)
                .Select(module => 
                {
                    string moduleName = module.First().ModuleName;
                    string code = string.Join("", module.Select(m => m.Code));
                    StringBuilder sb = new StringBuilder();

                    sb.AppendLine("/// <auto-generated>");
                    sb.AppendLine($"/// This code was auto-generated by Dogma for .NET Core on {DateTime.UtcNow} UTC. Do not manually edit this file.");
                    sb.AppendLine("/// </auto-generated>");
                    sb.AppendLine($"declare module \"{moduleName}\" {{");
                    sb.Append(code);
                    sb.Append("}");

                    return new GeneratedFile(moduleName, sb.ToString());
                });
        }

        private IEnumerable<TypeData> GetTypesWithAttribute(Assembly assembly)
        {
            foreach (TypeInfo info in assembly.DefinedTypes)
            {
                var attribute = info.GetCustomAttribute(typeof(ToTypeScriptAttribute), true) as ToTypeScriptAttribute;

                if (attribute != null)
                {
                    var data = new TypeData()
                    {
                        TypeInfo = info,
                        Attribute = attribute
                    };

                    yield return data;
                }
            }
        }

        private IEnumerable<Type> DiscoverClassesFromProps(TypeInfo info)
        {
            string breaker = null;
            return info.DeclaredProperties
                .Select(prop => prop.PropertyType.GetTypeInfo())
                .Where(propInfo => propInfo.IsClass)
                .Select(propInfo => propInfo.GetElementType());
        }

        private string GetTSType(Type type)
        {
            if (type.IsArray)
            {
                var arrayType = GetTSType(type.GetElementType());

                return arrayType + "[]";
            }

            if (type == typeof(String))
            {
                return "string";
            }

            if (type == typeof(Boolean))
            {
                return "boolean";
            }

            if (type == typeof(DateTime) || type == typeof(DateTimeOffset))
            {
                return "Date";
            }

            if (IsNumber(type))
            {
                return "number";
            }

            if (IsEnumerable(type) && type.IsConstructedGenericType)
            {
                var genericType = GetTSType(type.GenericTypeArguments.First());

                return genericType + "[]";
            }

            return type.Name;
        }

        private bool IsNumber(Type type)
        {
            Type[] numberTypes = { 
                typeof(sbyte),
                typeof(byte),
                typeof(short),
                typeof(ushort),
                typeof(int),
                typeof(uint),
                typeof(long),
                typeof(ulong),
                typeof(float),
                typeof(double),
                typeof(decimal)
            };

            return numberTypes.Contains(type);
        }

        private bool IsEnumerable(Type type)
        {
            var info = type.GetTypeInfo();

            return info.ImplementedInterfaces.Contains(typeof(System.Collections.IEnumerable));
        }

        private bool IsClass(Type type)
        {
            var info = type.GetTypeInfo();

            return info.IsClass;
        }
    }
}